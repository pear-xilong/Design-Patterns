### JavaScript 设计模式核心原理与应用实践

> #### 1. 设计模式之道

**SOLID 设计原则**
设计原则是设计模式的指导理论，它可以帮助我们规避不良的软件设计。SOLID 指代的五个基本原则分别是：

> **单一功能原则（Single Responsibility Principle** > **开放封闭原则（Opened Closed Principle）**
> 里式替换原则（Liskov Substitution Principle）
> 接口隔离原则（Interface Segregation Principle）
> 依赖反转原则（Dependency Inversion Principle）

将 23 种设计模式按照“创建型”、“行为型”和“结构型”进行划分：
![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/6/169f16406d230ffe~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

> #### 2. 设计模式

> 1. 工厂模式 (创建型)
>    概念: 工厂模式其实就是将创建对象的过程单独封装
>    总结： 工厂模式的简单之处，在于它的概念相对好理解：将创建对象的过程单独封装，这样的操作就是工厂模式。同时它的应用场景也非常容易识别：有构造函数的地方，我们就应该想到简单工厂；在写了大量构造函数、调用了大量的 new、自觉非常不爽的情况下，我们就应该思考是不是可以掏出工厂模式重构我们的代码了。

> 2. 抽象工厂模式 (创建型)
>    概念: 抽象工厂模式的定义，是围绕一个超级工厂创建其他工厂
>    抽象工厂（抽象类，它不能被用于生成具体实例）： 用于声明最终目标产品的共性。在一个系统里，抽象工厂可以有多个（大家可以想象我们的手机厂后来被一个更大的厂收购了，这个厂里除了手机抽象类，还有平板、游戏机抽象类等等），每一个抽象工厂对应的这一类的产品，被称为“产品族”。
>    具体工厂（用于生成产品族里的一个具体的产品）： 继承自抽象工厂、实现了抽象工厂里声明的那些方法，用于创建具体的产品的类。
>    抽象产品（抽象类，它不能被用于生成具体实例）： 上面我们看到，具体工厂里实现的接口，会依赖一些类，这些类对应到各种各样的具体的细粒度产品（比如操作系统、硬件等），这些具体产品类的共性各自抽离，便对应到了各自的抽象产品类。
>    具体产品（用于生成产品族里的一个具体的产品所依赖的更细粒度的产品）： 比如我们上文中具体的一种操作系统、或具体的一种硬件等。

> 3. 单例模式 (创建型)
>    概念: 保证一个类仅有一个实例，并提供一个访问它的全局访问点
>    不管我们尝试去创建多少次，它都只给你返回第一次所创建的那唯一的一个实例。
>    场景： modal 模态框

> 4. 原型模式 (创建型)
>    概念: 原型编程范式的核心思想就是利用实例来描述对象，用实例作为定义对象和继承的基础
>    原型编程范式的核心思想就是利用实例来描述对象，用实例作为定义对象和继承的基础。在 JavaScript 中，原型编程范式的体现就是基于原型链的继承。

> 5. 装饰者模式 (结构型)
>    装饰器模式，又名装饰者模式。它的定义是“在不改变原对象的基础上，通过对其进行包装拓展，使原有对象可以满足用户的更复杂需求”
>    它本质上是一个函数，而且往往不依赖于任何逻辑而存在
>    定义装饰器函数，将被装饰者“交给”装饰器

> 6. 适配器模式 (结构型)
>    适配器模式通过把一个类的接口变换成客户端所期待的另一种接口，可以帮我们解决不兼容的问题
>    用于适配两个接口不兼容的情况，不需要改变已有的接口，就能够使它们协同作用

> 7. 代理模式 (结构型)
>    A 不能直接访问 B，A 需要借助一个帮手来访问 B，这个帮手就是代理器。需要代理器出面解决的问题，就是代理模式发光发热的应用场景。
>    最常见的四种代理类型：事件代理、虚拟代理、缓存代理和保护代理

> 8. 策略模式 (行为型)
>    定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
>    利用对象映射的方式，将多个 if-else 分支的逻辑拆分成了多个对象中的方法，这些方法可以根据传入的参数不同，返回不同的结果，从而避免了 if-else 分支逻辑的臃肿。

> 8. 状态模式 (行为型)
>    状态模式(State Pattern) ：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。
>    状态模式主要解决的是当控制一个对象状态的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。
>    策略模式和状态模式的区别在于它们所关注的点不同，策略模式关注的是算法或行为的切换，状态模式关注的是对象的状态的切换。

> 9. 观察者模式 (行为型)
>    观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新
>    目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新
>    **观察者模式与发布-订阅模式的区别是什么？**
>    这种发布者直接触及到订阅者的操作，叫观察者模式。但如果韩梅梅没有拉群，而是把需求文档上传到了公司统一的需求平台上，需求平台感知到文件的变化、自动通知了每一位订阅了该文件的开发者，这种发布者不直接触及到订阅者、而是由统一的第三方来完成实际的通信的操作，叫做发布-订阅模式。

> 10. 迭代器对象 (行为型)
>     迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示
>     迭代器模式是设计模式中少有的目的性极强的模式。所谓“目的性极强”就是说它不操心别的，它就解决这一个问题——遍历
