### JavaScript 设计模式核心原理与应用实践

> #### 1. 设计模式之道

**SOLID 设计原则**
设计原则是设计模式的指导理论，它可以帮助我们规避不良的软件设计。SOLID 指代的五个基本原则分别是：

> **单一功能原则（Single Responsibility Principle**
> **开放封闭原则（Opened Closed Principle）**
> 里式替换原则（Liskov Substitution Principle）
> 接口隔离原则（Interface Segregation Principle）
> 依赖反转原则（Dependency Inversion Principle）

将 23 种设计模式按照“创建型”、“行为型”和“结构型”进行划分：
![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/6/169f16406d230ffe~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

> #### 2. 设计模式

> 1. 工厂模式 (创建型)
>    概念: 工厂模式其实就是将创建对象的过程单独封装
>    总结： 工厂模式的简单之处，在于它的概念相对好理解：将创建对象的过程单独封装，这样的操作就是工厂模式。同时它的应用场景也非常容易识别：有构造函数的地方，我们就应该想到简单工厂；在写了大量构造函数、调用了大量的 new、自觉非常不爽的情况下，我们就应该思考是不是可以掏出工厂模式重构我们的代码了。

> 2. 抽象工厂模式 (创建型)
>    概念: 抽象工厂模式的定义，是围绕一个超级工厂创建其他工厂
>    抽象工厂（抽象类，它不能被用于生成具体实例）： 用于声明最终目标产品的共性。在一个系统里，抽象工厂可以有多个（大家可以想象我们的手机厂后来被一个更大的厂收购了，这个厂里除了手机抽象类，还有平板、游戏机抽象类等等），每一个抽象工厂对应的这一类的产品，被称为“产品族”。
>    具体工厂（用于生成产品族里的一个具体的产品）： 继承自抽象工厂、实现了抽象工厂里声明的那些方法，用于创建具体的产品的类。
>    抽象产品（抽象类，它不能被用于生成具体实例）： 上面我们看到，具体工厂里实现的接口，会依赖一些类，这些类对应到各种各样的具体的细粒度产品（比如操作系统、硬件等），这些具体产品类的共性各自抽离，便对应到了各自的抽象产品类。
>    具体产品（用于生成产品族里的一个具体的产品所依赖的更细粒度的产品）： 比如我们上文中具体的一种操作系统、或具体的一种硬件等。

> 3. 单例模式 (创建型)
>    概念: 保证一个类仅有一个实例，并提供一个访问它的全局访问点
>    不管我们尝试去创建多少次，它都只给你返回第一次所创建的那唯一的一个实例。
>    场景： modal 模态框

> 4. 原型模式 (创建型)
>    概念: 原型编程范式的核心思想就是利用实例来描述对象，用实例作为定义对象和继承的基础
>    原型编程范式的核心思想就是利用实例来描述对象，用实例作为定义对象和继承的基础。在 JavaScript 中，原型编程范式的体现就是基于原型链的继承。

> 5. 装饰者模式 (结构型)
>    装饰器模式，又名装饰者模式。它的定义是“在不改变原对象的基础上，通过对其进行包装拓展，使原有对象可以满足用户的更复杂需求”

